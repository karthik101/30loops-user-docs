=======================
30loops platform manual
=======================

.. note::

    This manual is still a work in progress. Examples my differ from the actual
    client output.

Platform basics
===============

Working on the platform consists mainly of two tasks:

#) Creating, editing and deleting resources

   You can manipulate the configuration of your resources. This can be done by
   sending valid JSON messages to the API. To simplify this, you can
   generate the messages by using the :doc:`client`.

#) Queuing actions for a resource

   This manipulates the physical state of your resources. You can deploy or run
   commands in the context of your resource on the platform. Each resource
   accepts different actions. The ``thirty`` client supports all available
   actions. In the :doc:`REST API guide <rest_api>` the actions are explained
   in more detail.

To use the client, you need to have a valid, active account.

.. note::

    The quickstart guide assumes that you use the ``thirty`` client command for
    all operations. Of course, you can also create the necessary JSON messages 
    by hand or have them generated by some tool.

Resources
---------

On 30loops, every service is called a resource. Examples of resources are 
databases, applications and repositories. A resource is represented as a json 
message, and each resource has several keys and values. The resources are 
described in detail in the :doc:`REST API guide <rest_api>`.

A resource has at least the following fields:

**name**
  The name is a unique identifier. Each resource must have a unique name
  together with the label for this account, eg: You can have an app and a
  repository that both have the name ``blog``, but not two apps or two
  repositories.

**label**
  A resource has a label. This label describes the service. At this moment we
  support the following resource types:

  - app
  - repository
  - database

**variant**
  A resource can have a variant. At this moment we have only one variant per
  resource, but this will change in the future.


Environments
------------

One of the unique features of our platform is the fact that you can create
multiple environments per application. This means you can create a staging,
development and production environment, that all share the same repository.

Application layout
------------------

We tried to give you as much freedom as possible in setting up your repository
structure. To make a succesfull deploy we need to know a few things though. 

You have to specify the project root. This is a relative path from the root of
your repository to where the actual project files are residing, eg: you django
project.

For example the following directory layout is possible::

    +--> setup.py
    +--> django_project
    |    +--> manage.py
    |    +--> urls.py
    |    +--> settings
    |    |    +--> __init__.py
    |    |    +--> production.py
    |    +--> templates
    +--> apps
         +--> blog
              +--> ..

You configure ``project_root`` to ``django_project`` and enable
``install_setup_py`` by setting it to ``true``. The deploy runs a ``python
setup.py install`` to install your apps into the python path. And the appserver
and the ``djangocommand`` action know which directory hosts your actual
project. 

For WSGI apps this is similar::

    +--> src
         +--> myawesomeblog
              +--> __init__.py
              +--> app.py

By setting ``project_root`` to ``src/myawsomeblog/``, the right directory
gets added to the python path. Import paths like ``from myawesomeblog.app
import application`` are possible then.

Environment variables
---------------------

You can access the most important values of your environment inside of an
instance. There are two files, ``/app/conf/environment.conf`` and
``/app/conf/environment.json``. You can use them inside any shell script or
python script that you maybe want to run. For a shell script you can source the
``.conf`` file. You can read the json file in any python script and load the
string.

::

    cat /app/conf/environment.conf

    export VIRTUAL_ENV="/app/env"
    export STATIC_ROOT="/app/static"
    export MEDIA_ROOT="/app/media"
    export DB_PORT="9999"
    export PATH="/app/env/bin:/bin:/usr/bin"
    export DB_USER="30loops-app-thirtyblog"
    export DB_NAME="30loops-app-thirtyblog-production"
    export DB_HOST="pg.30loops.net"
    export DB_PASSWORD="ZjBmNDEyMWJj"
    export DJANGO_SETTINGS_MODULE="settings"
    export DJANGO_PROJECT_ROOT="thirtyblog"

Add to your script the following line.

.. code-block:: sh

    #!/bin/bash
    ...
    source /app/conf/environment.conf
    ...
    echo $DB_PORT

::

    cat /app/conf/environment.json

    {
        {'VIRTUAL_ENV': '/app/env'},
        {'STATIC_ROOT': '/app/static'},
        {'MEDIA_ROOT': '/app/media'},
        {'DB_PORT': '9999'},
        {'PATH': '/app/env/bin:/bin:/usr/bin'},
        {'DB_USER': '30loops-app-thirtyblog'},
        {'DB_NAME': '30loops-app-thirtyblog-production'},
        {'DB_HOST': 'pg.30loops.net'},
        {'DB_PASSWORD': 'ZjBmNDEyMWJj'},
        {'DJANGO_SETTINGS_MODULE': 'settings'},
        {'DJANGO_PROJECT_ROOT': 'thirtyblog'},
        {'APP_USER': '30loops-app-thirtyblog'}
    }

For your python application you can use something like:

.. code-block:: py

    import json
    with open('/app/conf/environment.json') as f:
        env = json.load(f)

    print env['DB_PORT']

Runtime environment
-------------------

The instances run on Ubuntu 12.04, and contain the following installed python
packages::

    python-setuptools
    python-pip
    python-virtualenv
    python-imaging
    python-geoip
    python-gdal
    python-numpy
    python-scipy
    python-bcrypt
    python-gdata
    python-m2crypto
    python-nltk
    python-matplotlib
    python-opencv
    python-sqlalchemy
    python-psycopg2
    python-mysqldb
    python-eventlet
    python-gevent
    python-lxml
    python-geoip
    python-setproctitle



Static and Media files
----------------------

Static content are files like css or javascript. They get placed with every
deploy. Each instance has its own copies of those files. Media files are shared
among all instances and stored on a mass storage device. They are not changed
during a deploy and are meant for user generated content. 

Paths to static and media files is handled per convention right now. The
webserver is configured to server static files from the path ``/static/`` and
media files from the path ``/media/``. The path locations on the instance are
``/app/static`` and ``/app/media`` respectively. You have to configure your
app accordingly if needed.

Postinstall hook
----------------

After each deploy the scripts ``postinstall`` and ``postinstall_all`` are
executed. The ``postinstall`` script runs only on the first created instance,
while the ``postinstall_all`` script runs on every instance.

The script needs to be in the root of your repository, and must be executable. 
This script can be any language, just provide the right shebang:

For Python code:

.. code-block:: bash

    $ cat postinstall
    #!/usr/bin/env python
    run_some_function()

Or for example some BASH code:

.. code-block:: bash

    $ cat postinstall_all
    #!/bin/sh
    cp someimagefile /app/static

This would also be the correct place to run a syncdb after each deploy:

.. code-block:: bash

    #!/bin/sh
    python manage.py syncdb --noinput

.. note::

    The deployment process will fail if the script ends with an error return 
    code!

Thirty client
=============

Installation
------------

To install the ``thirty-cli`` run::

    pip install -U thirty-cli

This should install all necessary requirements:

- python-docar
- libthirty
- requests
- argparse

If you don't have ``pip`` installed you can also use ``easy_install``::

    easy_install -U thirty-cli

Basics
------

The client is quite self-explaining. When you just type in ``thirty`` you will 
get an overview of the various options. The basic structure of a command is::

    thirty <command> <subcommand> --flag1 somevariable --flag2 somevariable


Help on commands
----------------

You can get help of a function by running one of the following commands::

    thirty help <command>
    thirty help <command> <subcommand>

Each command has its own set of subcommands and flags.

Global Options
--------------

The ``thirty`` command line tool uses a few global options to set stuff like
authentication credentials or output formats. You can also omit them and
configure a `thirty.cfg Configuration File`_ to specify those values. Global
options specified on the command line take precedence over options specified in
the config file.

``-u, --username`` *<username>*
  Specify the username to use when authenticating a request to the API
  endpoints.

``-p, --password`` *<password>*
  Specify the password to use when authenticating a request to the API
  endpoints.

``-a, --account`` *<account>*
  Specify the account name when sending a request to the API endpoint.

``-r, --uri`` *<uri>*
  Specify the API URI to use for the request. The default API URI is
  ``https://api.30loops.net/``. You can override the default URI here.

``-i, --api`` *<api>*
  Specify the default API version to use when making a request. The default is
  ``1.0``. You can override the default API version here.

``-R, --raw``
  Use a raw mode for printing output. The raw mode prints JSON messages as
  returned from the server, with out any indendation. This is handy if you want
  to use the ``thirty`` tool in scripts.
    
``thirty.cfg`` Configuration File
---------------------------------

You can create a configuration file in your home directory called
``.thirty.cfg``. Specify any global option there to save yourself the typing::

    cat ~/.thirty.cfg 
    [thirtyloops]
    username = crito
    password = secret
    account = 30loops

The configuration file follows a simple INI style and collects all global
options under a section called ``[thirtyloops]``. Global options specified on
the command line take precedence over options specified in the config file.

Commands
--------

list
~~~~

::

    thirty list <label>

List all resources with the given label.

**Example:**

::

    $ thirty list app
    thirtyloops
    djangocms

show
~~~~

::

    thirty show <resource> <name> [environment]

Show the details of a resource. If ``[environment]`` is given it will show the
details of a specific app environment instead of the app itself.

**Example:**

::

    $ thirty show repository djangocms
    name: djangocms
    variant: git
    label: repository
    location: git://github.com/bastichelaar/Django-CMS-30loops.git

create 
~~~~~~
::

    thirty create <label> <name> [location]

Create a new resource. Each resource has its own set of flags. Note that 
database resources cannot be created manually, but will be created when 
creating an application environment.

**flags**

``--root``
  This flag specifies where the root of your application is. By default this is 
  set to the most upper directory.

``--flavor``
  The flavor flag needs to be set for every application. Currently we have the 
  ``wsgi`` flavor and ``django`` flavor.

``--cname``
  Use this option if you use a custom domain. Create a CNAME record for your 
  domain and point it to the default application name on 30loops (for example
  30loops-app-djangocms-production.30loops.net).

``--environment``
  By default, the created environment will be named ``production``. You can 
  override this by specifying a custon environment name.

``--requirements``
  This option specifies the file to use for the pip install command. By default
  this is set to ``requirements.txt``.

``--install-setup-py``
  This flag enables or disables the ``python setup.py install`` command. If you
  need to run this on deployment, please set it to ``true``. Default is 
  ``false``.

``--backends``
  This flag specifies the number of backends to deploy on. By default it is set
  to 1.

**Django specific options**

``--inject-db``
  This tells the server to automaticaly inject the database settings during the
  deploy. The database settings are injected at the bottom of the settings file 
  you specified. By default, this option is set to ``true``.

``--django-settings-module``
  This is the python module path to your settings file. This has to be 
  specified in a dotted syntax, for example: ``module.settings``. By default
  this option is set to ``settings``.

.. _`Django`: http://djangoproject.com
.. _`example repository`: https://github.com/30loops/django-cms-30loops


**WSGI specific options**

``--wsgi-entrypoint``
  This flag specifies the entrypoint of your application. Each incoming 
  request will be routed to this function. WSGI entrypoints have to be specified 
  in the following format: ``python.module.path:callable``, for example
  ``wsgiapp.main:application``.

update
~~~~~~
::

    thirty update <lable> <resource_name> [environment]

Update the details of a resource. If ``[environment]`` is given it will update the
details of a specific app environment instead of the app itself.

**Flags**

All flags of the create command are available. Additionally, these flags are
available on the ``update`` command:

``--repo-branch``
  This option specifies which branch of the repository to fetch. By default this
  is set to ``master``.

``--repo-commit``
  This option specifies which commit of the repository to fetch. By default this
  is set to ``HEAD``.

``--add-cname``
  This flag adds an additional CNAME to the environment.

``--del-cname``
  This flag deletes a CNAME from the environment.

delete
~~~~~~

::

    thirty delete <lable> <resource_name> [environment]

Delete a resource. If ``[environment]`` is given it will delete the app
environment instead of the app itself.

deploy
~~~~~~

::

    thirty deploy <app> <environment>

Deploy a specific app environment. It queues a new deployment of that
environment. See :doc:`REST API guide <rest_api>` for more information about
deploys.

runcmd
~~~~~~

::

    thirty runcmd <app> <environment> "<command>"

Run a command in the context of your app environment. The full command is
specified enclosed by ``"``. The working directory of this command is the root
of your repository. 

**Example:**

::

    thirty runcmd thirtyblog production "python init_db.py"

**Options:**

``--occurence``
  Specifies on how many backends this command should be executed on. You can
  either specify a number or ``all``. Defaults to ``1``.

djangocmd
~~~~~~~~~

::

    thirty djangocmd <app> <environment> "<management command>"

Run a django management command in the context of your django project. The full
command is specified enclosed by ``"``. The working directory of this command
is the root of your repository. You don't have to specify any settings module
or start the command with ``python manage.py``.

**Example:**

::

    thirty djangocmd thirtyblog production "syncdb"

**Options:**

``--occurence``
  Specifies on how many backends this command should be executed on. You can
  either specify a number or ``all``. Defaults to ``1``.

Cronjobs
========

Every instance runs cron by default. So you can easily create cronjobs to run on
one instance or on every instance. To do this, you need to create a cron file,
for example ``mycrontab``:

.. code-block:: bash
    
    $ cat mycrontab
    0 * * * * python myscript.py

To learn more about the format of the crontab file, see 
http://en.wikipedia.org/wiki/Cron#Format.

To install the cronjob, you need to add a line to either ``postinstall`` or
``postinstall_all``, depending on if you want the cronjob to run a single 
instance or on every instance. Example:

.. code-block:: bash

    $ cat postinstall
    #!/bin/sh
    crontab mycrontab

This will install the cron after deploying your application.

Running custom processes (unsupported!)
=======================================

It is possible to run your own custom processes. The processes will run as a
non-privileged user. To create a custom process, you need to add a ``.init/``
directory to your repository. In this ``.init/`` directory you need to create
an upstart file, that will be started after the deploy of an instance.

So the tree could look like:

.. code-block:: bash

    +--> .init
    |    +--> myprocess.conf
    +--> mycms
    |    +--> ..
    +--> requirements.txt 
    +--> postinstall

The process file is an upstart configuration file. A very simple example:

.. code-block:: bash

    $ cat .init/myprocess.conf
    respawn

    exec /app/mycms/mycms/mycustomprocess

The process will not be started by default, so you need to add an additional 
line to the ``postinstall`` script:

.. code-block:: bash

    $ cat postinstall
    #!/bin/sh
    crontab mycrontab
    start myprocess

For more information about upstart processes, read the Ubuntu Upstart Cookbook:
http://upstart.ubuntu.com/cookbook/.

Note: custom processes are completely unsupported!


Guides
======

We created a few guides with some sample applications. This will be extended in
the future with more samples.

Django
------
- :doc:`Django CMS <django>`

WSGI
----
- :doc:`Simple WSGI app <wsgi>`

.. include:: debugging.rst 
